
EEPROM to PCA-42.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000712  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  00000786  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000077  00802000  00802000  00000786  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000786  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000007b8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000c0  00000000  00000000  000007f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003ca0  00000000  00000000  000008b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002bf7  00000000  00000000  00004558  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b33  00000000  00000000  0000714f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000288  00000000  00000000  00007c84  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000024dd  00000000  00000000  00007f0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000d63  00000000  00000000  0000a3e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a0  00000000  00000000  0000b14c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
   8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
   c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  10:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  14:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  18:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  1c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  20:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  24:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  28:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  2c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  30:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  34:	0c 94 4c 02 	jmp	0x498	; 0x498 <__vector_13>
  38:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  3c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  40:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  44:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  48:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  4c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  50:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  54:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  58:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  5c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  60:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  64:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  68:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  6c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  70:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  74:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  78:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  7c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  80:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  84:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  88:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  8c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  90:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  94:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  98:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  9c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  a0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  a4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  a8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  ac:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  b0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  b4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  b8:	0c 94 72 02 	jmp	0x4e4	; 0x4e4 <__vector_46>
  bc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  c0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  c4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  c8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  cc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  d0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  d4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  d8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  dc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  e0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  e4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  e8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  ec:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  f0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  f4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  f8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  fc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 100:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 104:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 108:	0c 94 98 02 	jmp	0x530	; 0x530 <__vector_66>
 10c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 110:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 114:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 118:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 11c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 120:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 124:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 128:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 12c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 130:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 134:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 138:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 13c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 140:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 144:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 148:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 14c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 150:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 154:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 158:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 15c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 160:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 164:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 168:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 16c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 170:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 174:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 178:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 17c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 180:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 184:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 188:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 18c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 190:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 194:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 198:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 19c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1a0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1a4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1a8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1ac:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1b0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1b4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1b8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1bc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1c0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1c4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1c8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1cc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1d0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1d4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1d8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1dc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1e0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1e4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1e8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1ec:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1f0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1f4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1f8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e2       	ldi	r29, 0x2F	; 47
 206:	de bf       	out	0x3e, r29	; 62

00000208 <__do_clear_bss>:
 208:	20 e2       	ldi	r18, 0x20	; 32
 20a:	a0 e0       	ldi	r26, 0x00	; 0
 20c:	b0 e2       	ldi	r27, 0x20	; 32
 20e:	01 c0       	rjmp	.+2      	; 0x212 <.do_clear_bss_start>

00000210 <.do_clear_bss_loop>:
 210:	1d 92       	st	X+, r1

00000212 <.do_clear_bss_start>:
 212:	a7 37       	cpi	r26, 0x77	; 119
 214:	b2 07       	cpc	r27, r18
 216:	e1 f7       	brne	.-8      	; 0x210 <.do_clear_bss_loop>
 218:	0e 94 24 02 	call	0x448	; 0x448 <main>
 21c:	0c 94 87 03 	jmp	0x70e	; 0x70e <_exit>

00000220 <__bad_interrupt>:
 220:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000224 <initialize>:

/*
Initializes clock, pins, and various peripherals for an ATxmegaA4U
*/
void initialize(void)
{
 224:	cf 93       	push	r28
 226:	df 93       	push	r29
	//Clock initialization
	OSC_CTRL |= OSC_RC32MEN_bm; //enable 32MHz Internal Oscillator
 228:	e0 e5       	ldi	r30, 0x50	; 80
 22a:	f0 e0       	ldi	r31, 0x00	; 0
 22c:	80 81       	ld	r24, Z
 22e:	82 60       	ori	r24, 0x02	; 2
 230:	80 83       	st	Z, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 232:	87 e8       	ldi	r24, 0x87	; 135
 234:	93 e1       	ldi	r25, 0x13	; 19
 236:	01 97       	sbiw	r24, 0x01	; 1
 238:	f1 f7       	brne	.-4      	; 0x236 <initialize+0x12>
 23a:	00 c0       	rjmp	.+0      	; 0x23c <initialize+0x18>
 23c:	00 00       	nop
	_delay_ms(1); //time needed for 32MHz to stabilize
	CCP = CCP_IOREG_gc; // allow change to protected IO registers
 23e:	88 ed       	ldi	r24, 0xD8	; 216
 240:	84 bf       	out	0x34, r24	; 52
	CLK_CTRL = CLK_SCLKSEL_RC32M_gc; //select 32MHz internal oscillator
 242:	21 e0       	ldi	r18, 0x01	; 1
 244:	20 93 40 00 	sts	0x0040, r18	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
	
	//Port A initialization
	PORTA_PIN1CTRL = PORT_OPC_PULLUP_gc; PORTA_PIN2CTRL = PORT_OPC_PULLUP_gc; PORTA_PIN3CTRL = PORT_OPC_PULLUP_gc; //pullups on encdr-A, encdr-B and encdr-SW
 248:	c1 e1       	ldi	r28, 0x11	; 17
 24a:	d6 e0       	ldi	r29, 0x06	; 6
 24c:	88 e1       	ldi	r24, 0x18	; 24
 24e:	88 83       	st	Y, r24
 250:	a2 e1       	ldi	r26, 0x12	; 18
 252:	b6 e0       	ldi	r27, 0x06	; 6
 254:	8c 93       	st	X, r24
 256:	e3 e1       	ldi	r30, 0x13	; 19
 258:	f6 e0       	ldi	r31, 0x06	; 6
 25a:	80 83       	st	Z, r24
	PORTA_PIN1CTRL |= PORT_ISC_BOTHEDGES_gc; PORTA_PIN2CTRL |= PORT_ISC_BOTHEDGES_gc; //both edges interrupts on encdr-A and encdr-B
 25c:	98 81       	ld	r25, Y
 25e:	98 83       	st	Y, r25
 260:	9c 91       	ld	r25, X
 262:	9c 93       	st	X, r25
	PORTA_PIN3CTRL |= PORT_ISC_FALLING_gc; //falling edge interrupt on encdr-SW
 264:	90 81       	ld	r25, Z
 266:	92 60       	ori	r25, 0x02	; 2
 268:	90 83       	st	Z, r25
	PORTA_INT0MASK = (0x7 << 1); //enables interrupts on encdr-A,encdr-B,encdr-SW
 26a:	9e e0       	ldi	r25, 0x0E	; 14
 26c:	90 93 0a 06 	sts	0x060A, r25	; 0x80060a <__TEXT_REGION_LENGTH__+0x70060a>
	PORTA_INTCTRL = PORT_INT0LVL_LO_gc; //enable port A interrupts
 270:	20 93 09 06 	sts	0x0609, r18	; 0x800609 <__TEXT_REGION_LENGTH__+0x700609>
	
	PORTA_DIRSET = (1 << GRN_LED); //set grn led to output
 274:	e1 e0       	ldi	r30, 0x01	; 1
 276:	f6 e0       	ldi	r31, 0x06	; 6
 278:	30 e2       	ldi	r19, 0x20	; 32
 27a:	30 83       	st	Z, r19
	PORTA_DIRSET = (1 << RED_LED); //set red led to output
 27c:	90 e1       	ldi	r25, 0x10	; 16
 27e:	90 83       	st	Z, r25
	GRN_LED_OFF;
 280:	e5 e0       	ldi	r30, 0x05	; 5
 282:	f6 e0       	ldi	r31, 0x06	; 6
 284:	30 83       	st	Z, r19
	RED_LED_OFF;
 286:	90 83       	st	Z, r25
	
	//Port B initialization
	
	
	//Port C initialization
	PORTC_DIRSET = (1 << SCL_C); PORTC_OUTSET = (1 << SCL_C); //output/high on SCL
 288:	92 e0       	ldi	r25, 0x02	; 2
 28a:	90 93 41 06 	sts	0x0641, r25	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
 28e:	90 93 45 06 	sts	0x0645, r25	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
	PORTC_PIN0CTRL = PORT_OPC_PULLUP_gc; //pullup on SDA
 292:	80 93 50 06 	sts	0x0650, r24	; 0x800650 <__TEXT_REGION_LENGTH__+0x700650>
	
	//Port D initialization
	
	//Port E initialization
	PORTE_DIRSET = (1 << SCL_E); PORTE_OUTSET = (1 << SCL_E); //output/high on SCL
 296:	90 93 81 06 	sts	0x0681, r25	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
 29a:	90 93 85 06 	sts	0x0685, r25	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
	PORTE_PIN0CTRL = PORT_OPC_PULLUP_gc; //pullup on SDA
 29e:	80 93 90 06 	sts	0x0690, r24	; 0x800690 <__TEXT_REGION_LENGTH__+0x700690>
	
	//Port R initialization
	
	//SPI initialization
	PORTD_DIRSET = (1 << SS_D) | (1 << MOSI_D) | (1 << SCK_D); //output on SS, MOSI, and SCK
 2a2:	80 eb       	ldi	r24, 0xB0	; 176
 2a4:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <__TEXT_REGION_LENGTH__+0x700661>
	SPID_CTRL = (1 << SPI_ENABLE_bp) | (1 << SPI_MASTER_bp); //enable SPI, Master, set clock rate fck/4 (8 MHz), MSB first
 2a8:	80 e5       	ldi	r24, 0x50	; 80
 2aa:	80 93 c0 09 	sts	0x09C0, r24	; 0x8009c0 <__TEXT_REGION_LENGTH__+0x7009c0>
	
	
	//I2C initialization
	PMIC_CTRL = PMIC_LOLVLEN_bm; //enable low-lvl interrupts
 2ae:	20 93 a2 00 	sts	0x00A2, r18	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	TWI_MasterInit(&twiMaster, &TWIC, TWI_MASTER_INTLVL_LO_gc, TWI_BAUDSETTING);
 2b2:	2f e5       	ldi	r18, 0x5F	; 95
 2b4:	40 e4       	ldi	r20, 0x40	; 64
 2b6:	60 e8       	ldi	r22, 0x80	; 128
 2b8:	74 e0       	ldi	r23, 0x04	; 4
 2ba:	81 e0       	ldi	r24, 0x01	; 1
 2bc:	90 e2       	ldi	r25, 0x20	; 32
 2be:	0e 94 b2 02 	call	0x564	; 0x564 <TWI_MasterInit>
	
	//I2C initialization for external EEPROM
	TWI_MasterInit(&twiMasterForEEPROM, &TWIE, TWI_MASTER_INTLVL_LO_gc, TWI_BAUDSETTING);
 2c2:	2f e5       	ldi	r18, 0x5F	; 95
 2c4:	40 e4       	ldi	r20, 0x40	; 64
 2c6:	60 ea       	ldi	r22, 0xA0	; 160
 2c8:	74 e0       	ldi	r23, 0x04	; 4
 2ca:	8c e3       	ldi	r24, 0x3C	; 60
 2cc:	90 e2       	ldi	r25, 0x20	; 32
}
 2ce:	df 91       	pop	r29
 2d0:	cf 91       	pop	r28
	//I2C initialization
	PMIC_CTRL = PMIC_LOLVLEN_bm; //enable low-lvl interrupts
	TWI_MasterInit(&twiMaster, &TWIC, TWI_MASTER_INTLVL_LO_gc, TWI_BAUDSETTING);
	
	//I2C initialization for external EEPROM
	TWI_MasterInit(&twiMasterForEEPROM, &TWIE, TWI_MASTER_INTLVL_LO_gc, TWI_BAUDSETTING);
 2d2:	0c 94 b2 02 	jmp	0x564	; 0x564 <TWI_MasterInit>

000002d6 <read_external_eeprom>:
		}
	}
}

uint16_t read_external_eeprom(TWI_Master_t *twi, uint8_t eepromAddress, uint16_t dataAddress)
{
 2d6:	bf 92       	push	r11
 2d8:	cf 92       	push	r12
 2da:	df 92       	push	r13
 2dc:	ef 92       	push	r14
 2de:	ff 92       	push	r15
 2e0:	0f 93       	push	r16
 2e2:	1f 93       	push	r17
 2e4:	cf 93       	push	r28
 2e6:	df 93       	push	r29
 2e8:	cd b7       	in	r28, 0x3d	; 61
 2ea:	de b7       	in	r29, 0x3e	; 62
 2ec:	28 97       	sbiw	r28, 0x08	; 8
 2ee:	cd bf       	out	0x3d, r28	; 61
 2f0:	de bf       	out	0x3e, r29	; 62
 2f2:	8c 01       	movw	r16, r24
 2f4:	b6 2e       	mov	r11, r22
 2f6:	7a 01       	movw	r14, r20
	uint16_t received_data = 0;
	
	char message[8];
	message[0] = (uint8_t)(dataAddress >> 8);
 2f8:	f9 82       	std	Y+1, r15	; 0x01
	message[1] = (uint8_t)(dataAddress);
 2fa:	4a 83       	std	Y+2, r20	; 0x02
	TWI_MasterWrite(twi, eepromAddress, (uint8_t *) message, 2);
 2fc:	22 e0       	ldi	r18, 0x02	; 2
 2fe:	ae 01       	movw	r20, r28
 300:	4f 5f       	subi	r20, 0xFF	; 255
 302:	5f 4f       	sbci	r21, 0xFF	; 255
 304:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <TWI_MasterWrite>
 308:	2f e7       	ldi	r18, 0x7F	; 127
 30a:	38 e3       	ldi	r19, 0x38	; 56
 30c:	81 e0       	ldi	r24, 0x01	; 1
 30e:	21 50       	subi	r18, 0x01	; 1
 310:	30 40       	sbci	r19, 0x00	; 0
 312:	80 40       	sbci	r24, 0x00	; 0
 314:	e1 f7       	brne	.-8      	; 0x30e <read_external_eeprom+0x38>
 316:	00 c0       	rjmp	.+0      	; 0x318 <read_external_eeprom+0x42>
 318:	00 00       	nop
	_delay_ms(20);
	
	TWI_MasterRead(twi, eepromAddress, 1);
 31a:	41 e0       	ldi	r20, 0x01	; 1
 31c:	6b 2d       	mov	r22, r11
 31e:	c8 01       	movw	r24, r16
 320:	0e 94 00 03 	call	0x600	; 0x600 <TWI_MasterRead>
 324:	9f e7       	ldi	r25, 0x7F	; 127
 326:	e8 e3       	ldi	r30, 0x38	; 56
 328:	f1 e0       	ldi	r31, 0x01	; 1
 32a:	91 50       	subi	r25, 0x01	; 1
 32c:	e0 40       	sbci	r30, 0x00	; 0
 32e:	f0 40       	sbci	r31, 0x00	; 0
 330:	e1 f7       	brne	.-8      	; 0x32a <read_external_eeprom+0x54>
 332:	00 c0       	rjmp	.+0      	; 0x334 <read_external_eeprom+0x5e>
 334:	00 00       	nop
	_delay_ms(20);
	
	dataAddress++;
 336:	2f ef       	ldi	r18, 0xFF	; 255
 338:	e2 1a       	sub	r14, r18
 33a:	f2 0a       	sbc	r15, r18
	received_data = twi->readData[0] << 8;
 33c:	f8 01       	movw	r30, r16
 33e:	c4 8c       	ldd	r12, Z+28	; 0x1c
 340:	d1 2c       	mov	r13, r1
 342:	dc 2c       	mov	r13, r12
 344:	cc 24       	eor	r12, r12
	
	message[0] = (uint8_t)(dataAddress >> 8);
 346:	f9 82       	std	Y+1, r15	; 0x01
	message[1] = (uint8_t)(dataAddress);
 348:	ea 82       	std	Y+2, r14	; 0x02
	TWI_MasterWrite(twi, eepromAddress, (uint8_t *) message, 2);
 34a:	22 e0       	ldi	r18, 0x02	; 2
 34c:	ae 01       	movw	r20, r28
 34e:	4f 5f       	subi	r20, 0xFF	; 255
 350:	5f 4f       	sbci	r21, 0xFF	; 255
 352:	6b 2d       	mov	r22, r11
 354:	c8 01       	movw	r24, r16
 356:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <TWI_MasterWrite>
 35a:	ff e7       	ldi	r31, 0x7F	; 127
 35c:	28 e3       	ldi	r18, 0x38	; 56
 35e:	31 e0       	ldi	r19, 0x01	; 1
 360:	f1 50       	subi	r31, 0x01	; 1
 362:	20 40       	sbci	r18, 0x00	; 0
 364:	30 40       	sbci	r19, 0x00	; 0
 366:	e1 f7       	brne	.-8      	; 0x360 <read_external_eeprom+0x8a>
 368:	00 c0       	rjmp	.+0      	; 0x36a <read_external_eeprom+0x94>
 36a:	00 00       	nop
	_delay_ms(20);
	
	TWI_MasterRead(twi, eepromAddress, 1);
 36c:	41 e0       	ldi	r20, 0x01	; 1
 36e:	6b 2d       	mov	r22, r11
 370:	c8 01       	movw	r24, r16
 372:	0e 94 00 03 	call	0x600	; 0x600 <TWI_MasterRead>
 376:	8f e7       	ldi	r24, 0x7F	; 127
 378:	98 e3       	ldi	r25, 0x38	; 56
 37a:	e1 e0       	ldi	r30, 0x01	; 1
 37c:	81 50       	subi	r24, 0x01	; 1
 37e:	90 40       	sbci	r25, 0x00	; 0
 380:	e0 40       	sbci	r30, 0x00	; 0
 382:	e1 f7       	brne	.-8      	; 0x37c <read_external_eeprom+0xa6>
 384:	00 c0       	rjmp	.+0      	; 0x386 <read_external_eeprom+0xb0>
 386:	00 00       	nop
	_delay_ms(20);
	
	received_data |= twi->readData[0];
 388:	f8 01       	movw	r30, r16
 38a:	84 8d       	ldd	r24, Z+28	; 0x1c
	
	return received_data;
}
 38c:	96 01       	movw	r18, r12
 38e:	28 2b       	or	r18, r24
 390:	c9 01       	movw	r24, r18
 392:	28 96       	adiw	r28, 0x08	; 8
 394:	cd bf       	out	0x3d, r28	; 61
 396:	de bf       	out	0x3e, r29	; 62
 398:	df 91       	pop	r29
 39a:	cf 91       	pop	r28
 39c:	1f 91       	pop	r17
 39e:	0f 91       	pop	r16
 3a0:	ff 90       	pop	r15
 3a2:	ef 90       	pop	r14
 3a4:	df 90       	pop	r13
 3a6:	cf 90       	pop	r12
 3a8:	bf 90       	pop	r11
 3aa:	08 95       	ret

000003ac <write_external_eeprom>:

void write_external_eeprom(TWI_Master_t *twi, uint8_t eepromAddress, uint16_t dataAddress, uint16_t data)
{
 3ac:	af 92       	push	r10
 3ae:	bf 92       	push	r11
 3b0:	df 92       	push	r13
 3b2:	ef 92       	push	r14
 3b4:	ff 92       	push	r15
 3b6:	0f 93       	push	r16
 3b8:	1f 93       	push	r17
 3ba:	cf 93       	push	r28
 3bc:	df 93       	push	r29
 3be:	cd b7       	in	r28, 0x3d	; 61
 3c0:	de b7       	in	r29, 0x3e	; 62
 3c2:	28 97       	sbiw	r28, 0x08	; 8
 3c4:	cd bf       	out	0x3d, r28	; 61
 3c6:	de bf       	out	0x3e, r29	; 62
 3c8:	7c 01       	movw	r14, r24
 3ca:	d6 2e       	mov	r13, r22
 3cc:	8a 01       	movw	r16, r20
 3ce:	59 01       	movw	r10, r18
	uint16_t current_value = read_external_eeprom(twi, eepromAddress, dataAddress);
 3d0:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <read_external_eeprom>
	
	// If the current value in EEPROM is the same as the value that needs to be written then do not write it.
	// This saves some amount of writes used, since reads are free of charge, writes we only have about 100,000.
	// So, it is good to save as many writes as possible.
	if (current_value == data)
 3d4:	8a 15       	cp	r24, r10
 3d6:	9b 05       	cpc	r25, r11
 3d8:	51 f1       	breq	.+84     	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
	{
		return;
	}
	
	char message[8];
	message[0] = (uint8_t)(dataAddress >> 8);
 3da:	19 83       	std	Y+1, r17	; 0x01
	message[1] = (uint8_t)(dataAddress);
 3dc:	0a 83       	std	Y+2, r16	; 0x02
	message[2] = (uint8_t)(data >> 8);
 3de:	bb 82       	std	Y+3, r11	; 0x03
	TWI_MasterWrite(twi, eepromAddress, (uint8_t *) message, 3);
 3e0:	23 e0       	ldi	r18, 0x03	; 3
 3e2:	ae 01       	movw	r20, r28
 3e4:	4f 5f       	subi	r20, 0xFF	; 255
 3e6:	5f 4f       	sbci	r21, 0xFF	; 255
 3e8:	6d 2d       	mov	r22, r13
 3ea:	c7 01       	movw	r24, r14
 3ec:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <TWI_MasterWrite>
 3f0:	2f e7       	ldi	r18, 0x7F	; 127
 3f2:	88 e3       	ldi	r24, 0x38	; 56
 3f4:	91 e0       	ldi	r25, 0x01	; 1
 3f6:	21 50       	subi	r18, 0x01	; 1
 3f8:	80 40       	sbci	r24, 0x00	; 0
 3fa:	90 40       	sbci	r25, 0x00	; 0
 3fc:	e1 f7       	brne	.-8      	; 0x3f6 <write_external_eeprom+0x4a>
 3fe:	00 c0       	rjmp	.+0      	; 0x400 <__LOCK_REGION_LENGTH__>
 400:	00 00       	nop
	_delay_ms(20);

	dataAddress++;
 402:	0f 5f       	subi	r16, 0xFF	; 255
 404:	1f 4f       	sbci	r17, 0xFF	; 255
	
	message[0] = (uint8_t)(dataAddress >> 8);
 406:	19 83       	std	Y+1, r17	; 0x01
	message[1] = (uint8_t)(dataAddress);
 408:	0a 83       	std	Y+2, r16	; 0x02
	message[2] = (uint8_t)(data);
 40a:	ab 82       	std	Y+3, r10	; 0x03
	TWI_MasterWrite(twi, eepromAddress, (uint8_t *) message, 3);
 40c:	23 e0       	ldi	r18, 0x03	; 3
 40e:	ae 01       	movw	r20, r28
 410:	4f 5f       	subi	r20, 0xFF	; 255
 412:	5f 4f       	sbci	r21, 0xFF	; 255
 414:	6d 2d       	mov	r22, r13
 416:	c7 01       	movw	r24, r14
 418:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <TWI_MasterWrite>
 41c:	2f e7       	ldi	r18, 0x7F	; 127
 41e:	88 e3       	ldi	r24, 0x38	; 56
 420:	91 e0       	ldi	r25, 0x01	; 1
 422:	21 50       	subi	r18, 0x01	; 1
 424:	80 40       	sbci	r24, 0x00	; 0
 426:	90 40       	sbci	r25, 0x00	; 0
 428:	e1 f7       	brne	.-8      	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
 42a:	00 c0       	rjmp	.+0      	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
 42c:	00 00       	nop
	_delay_ms(20);
}
 42e:	28 96       	adiw	r28, 0x08	; 8
 430:	cd bf       	out	0x3d, r28	; 61
 432:	de bf       	out	0x3e, r29	; 62
 434:	df 91       	pop	r29
 436:	cf 91       	pop	r28
 438:	1f 91       	pop	r17
 43a:	0f 91       	pop	r16
 43c:	ff 90       	pop	r15
 43e:	ef 90       	pop	r14
 440:	df 90       	pop	r13
 442:	bf 90       	pop	r11
 444:	af 90       	pop	r10
 446:	08 95       	ret

00000448 <main>:

bool isLoading = FALSE;

int main(void)
{
	initialize(); //initializes clocks and pin settings
 448:	0e 94 12 01 	call	0x224	; 0x224 <initialize>

	sei();
 44c:	78 94       	sei
	
	while (1)
	{
		RED_LED_OFF;
 44e:	10 e1       	ldi	r17, 0x10	; 16
		GRN_LED_ON;
 450:	00 e2       	ldi	r16, 0x20	; 32

	sei();
	
	while (1)
	{
		RED_LED_OFF;
 452:	10 93 05 06 	sts	0x0605, r17	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
		GRN_LED_ON;
 456:	00 93 06 06 	sts	0x0606, r16	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
		
		if (isLoading)
 45a:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <_edata>
 45e:	88 23       	and	r24, r24
 460:	c1 f3       	breq	.-16     	; 0x452 <main+0xa>
		{
			RED_LED_ON;
 462:	10 93 06 06 	sts	0x0606, r17	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
			GRN_LED_OFF;
 466:	00 93 05 06 	sts	0x0605, r16	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
			
			for (int i = 0; i < 2700; i += 2)//2700
 46a:	c0 e0       	ldi	r28, 0x00	; 0
 46c:	d0 e0       	ldi	r29, 0x00	; 0
			{
				uint16_t data = read_external_eeprom(&twiMasterForEEPROM, EXTERNAL_EEPROM_ADDR, i);
 46e:	ae 01       	movw	r20, r28
 470:	61 e5       	ldi	r22, 0x51	; 81
 472:	8c e3       	ldi	r24, 0x3C	; 60
 474:	90 e2       	ldi	r25, 0x20	; 32
 476:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <read_external_eeprom>
				write_external_eeprom(&twiMaster, EXTERNAL_EEPROM_ADDR, i, data);
 47a:	9c 01       	movw	r18, r24
 47c:	ae 01       	movw	r20, r28
 47e:	61 e5       	ldi	r22, 0x51	; 81
 480:	81 e0       	ldi	r24, 0x01	; 1
 482:	90 e2       	ldi	r25, 0x20	; 32
 484:	0e 94 d6 01 	call	0x3ac	; 0x3ac <write_external_eeprom>
		if (isLoading)
		{
			RED_LED_ON;
			GRN_LED_OFF;
			
			for (int i = 0; i < 2700; i += 2)//2700
 488:	22 96       	adiw	r28, 0x02	; 2
 48a:	cc 38       	cpi	r28, 0x8C	; 140
 48c:	8a e0       	ldi	r24, 0x0A	; 10
 48e:	d8 07       	cpc	r29, r24
 490:	71 f7       	brne	.-36     	; 0x46e <main+0x26>
			{
				uint16_t data = read_external_eeprom(&twiMasterForEEPROM, EXTERNAL_EEPROM_ADDR, i);
				write_external_eeprom(&twiMaster, EXTERNAL_EEPROM_ADDR, i, data);
			}
			
			isLoading = FALSE;
 492:	10 92 00 20 	sts	0x2000, r1	; 0x802000 <_edata>
 496:	dd cf       	rjmp	.-70     	; 0x452 <main+0xa>

00000498 <__vector_13>:
	_delay_ms(20);
}


ISR(TWIC_TWIM_vect)
{
 498:	1f 92       	push	r1
 49a:	0f 92       	push	r0
 49c:	0f b6       	in	r0, 0x3f	; 63
 49e:	0f 92       	push	r0
 4a0:	11 24       	eor	r1, r1
 4a2:	2f 93       	push	r18
 4a4:	3f 93       	push	r19
 4a6:	4f 93       	push	r20
 4a8:	5f 93       	push	r21
 4aa:	6f 93       	push	r22
 4ac:	7f 93       	push	r23
 4ae:	8f 93       	push	r24
 4b0:	9f 93       	push	r25
 4b2:	af 93       	push	r26
 4b4:	bf 93       	push	r27
 4b6:	ef 93       	push	r30
 4b8:	ff 93       	push	r31
	TWI_MasterInterruptHandler(&twiMaster);
 4ba:	81 e0       	ldi	r24, 0x01	; 1
 4bc:	90 e2       	ldi	r25, 0x20	; 32
 4be:	0e 94 73 03 	call	0x6e6	; 0x6e6 <TWI_MasterInterruptHandler>
}
 4c2:	ff 91       	pop	r31
 4c4:	ef 91       	pop	r30
 4c6:	bf 91       	pop	r27
 4c8:	af 91       	pop	r26
 4ca:	9f 91       	pop	r25
 4cc:	8f 91       	pop	r24
 4ce:	7f 91       	pop	r23
 4d0:	6f 91       	pop	r22
 4d2:	5f 91       	pop	r21
 4d4:	4f 91       	pop	r20
 4d6:	3f 91       	pop	r19
 4d8:	2f 91       	pop	r18
 4da:	0f 90       	pop	r0
 4dc:	0f be       	out	0x3f, r0	; 63
 4de:	0f 90       	pop	r0
 4e0:	1f 90       	pop	r1
 4e2:	18 95       	reti

000004e4 <__vector_46>:
ISR(TWIE_TWIM_vect)
{
 4e4:	1f 92       	push	r1
 4e6:	0f 92       	push	r0
 4e8:	0f b6       	in	r0, 0x3f	; 63
 4ea:	0f 92       	push	r0
 4ec:	11 24       	eor	r1, r1
 4ee:	2f 93       	push	r18
 4f0:	3f 93       	push	r19
 4f2:	4f 93       	push	r20
 4f4:	5f 93       	push	r21
 4f6:	6f 93       	push	r22
 4f8:	7f 93       	push	r23
 4fa:	8f 93       	push	r24
 4fc:	9f 93       	push	r25
 4fe:	af 93       	push	r26
 500:	bf 93       	push	r27
 502:	ef 93       	push	r30
 504:	ff 93       	push	r31
	TWI_MasterInterruptHandler(&twiMasterForEEPROM);
 506:	8c e3       	ldi	r24, 0x3C	; 60
 508:	90 e2       	ldi	r25, 0x20	; 32
 50a:	0e 94 73 03 	call	0x6e6	; 0x6e6 <TWI_MasterInterruptHandler>
}
 50e:	ff 91       	pop	r31
 510:	ef 91       	pop	r30
 512:	bf 91       	pop	r27
 514:	af 91       	pop	r26
 516:	9f 91       	pop	r25
 518:	8f 91       	pop	r24
 51a:	7f 91       	pop	r23
 51c:	6f 91       	pop	r22
 51e:	5f 91       	pop	r21
 520:	4f 91       	pop	r20
 522:	3f 91       	pop	r19
 524:	2f 91       	pop	r18
 526:	0f 90       	pop	r0
 528:	0f be       	out	0x3f, r0	; 63
 52a:	0f 90       	pop	r0
 52c:	1f 90       	pop	r1
 52e:	18 95       	reti

00000530 <__vector_66>:

ISR(PORTA_INT0_vect)//interrupts from an encoder turn or push
{
 530:	1f 92       	push	r1
 532:	0f 92       	push	r0
 534:	0f b6       	in	r0, 0x3f	; 63
 536:	0f 92       	push	r0
 538:	11 24       	eor	r1, r1
 53a:	8f 93       	push	r24
	if (!isLoading)
 53c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <_edata>
 540:	81 11       	cpse	r24, r1
 542:	07 c0       	rjmp	.+14     	; 0x552 <__vector_66+0x22>
	{
		if(!(PORTA_IN & (1 << ENCDR_SW)))//if switch pin is low
 544:	80 91 08 06 	lds	r24, 0x0608	; 0x800608 <__TEXT_REGION_LENGTH__+0x700608>
 548:	83 fd       	sbrc	r24, 3
 54a:	03 c0       	rjmp	.+6      	; 0x552 <__vector_66+0x22>
		{
			isLoading = TRUE;
 54c:	81 e0       	ldi	r24, 0x01	; 1
 54e:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <_edata>
		}
	}
	
	PORTA_INTFLAGS = 0xFF; //clear port interrupt flags
 552:	8f ef       	ldi	r24, 0xFF	; 255
 554:	80 93 0c 06 	sts	0x060C, r24	; 0x80060c <__TEXT_REGION_LENGTH__+0x70060c>
 558:	8f 91       	pop	r24
 55a:	0f 90       	pop	r0
 55c:	0f be       	out	0x3f, r0	; 63
 55e:	0f 90       	pop	r0
 560:	1f 90       	pop	r1
 562:	18 95       	reti

00000564 <TWI_MasterInit>:
*/
bool TWI_MasterReady(TWI_Master_t *twi)
{
	bool twi_status = (twi->status & TWIM_STATUS_READY);
	return twi_status;
}
 564:	fc 01       	movw	r30, r24
 566:	60 83       	st	Z, r22
 568:	71 83       	std	Z+1, r23	; 0x01
 56a:	48 63       	ori	r20, 0x38	; 56
 56c:	db 01       	movw	r26, r22
 56e:	11 96       	adiw	r26, 0x01	; 1
 570:	4c 93       	st	X, r20
 572:	a0 81       	ld	r26, Z
 574:	b1 81       	ldd	r27, Z+1	; 0x01
 576:	15 96       	adiw	r26, 0x05	; 5
 578:	2c 93       	st	X, r18
 57a:	01 90       	ld	r0, Z+
 57c:	f0 81       	ld	r31, Z
 57e:	e0 2d       	mov	r30, r0
 580:	81 e0       	ldi	r24, 0x01	; 1
 582:	84 83       	std	Z+4, r24	; 0x04
 584:	08 95       	ret

00000586 <TWI_MasterWriteRead>:
*
*  \retval true  If transaction could be started.
*  \retval false If transaction could not be started.
*/
bool TWI_MasterWriteRead(TWI_Master_t *twi, uint8_t address, uint8_t *writeData, uint8_t bytesToWrite, uint8_t bytesToRead)
{
 586:	0f 93       	push	r16
 588:	cf 93       	push	r28
 58a:	df 93       	push	r29
 58c:	fc 01       	movw	r30, r24
	/*Parameter sanity check. */
	if (bytesToWrite > TWIM_WRITE_BUFFER_SIZE)
 58e:	2a 31       	cpi	r18, 0x1A	; 26
 590:	50 f5       	brcc	.+84     	; 0x5e6 <TWI_MasterWriteRead+0x60>
	{
		return false;
	}
	if (bytesToRead > TWIM_READ_BUFFER_SIZE)
 592:	0a 31       	cpi	r16, 0x1A	; 26
 594:	40 f5       	brcc	.+80     	; 0x5e6 <TWI_MasterWriteRead+0x60>
	{
		return false;
	}

	/*Initiate transaction if bus is ready. */
	if (twi->status == TWIM_STATUS_READY)
 596:	81 ad       	ldd	r24, Z+57	; 0x39
 598:	81 11       	cpse	r24, r1
 59a:	25 c0       	rjmp	.+74     	; 0x5e6 <TWI_MasterWriteRead+0x60>
	{

		twi->status = TWIM_STATUS_BUSY;
 59c:	81 e0       	ldi	r24, 0x01	; 1
 59e:	81 af       	std	Z+57, r24	; 0x39
		twi->result = TWIM_RESULT_UNKNOWN;
 5a0:	12 ae       	std	Z+58, r1	; 0x3a

		twi->address = address<<1;
 5a2:	66 0f       	add	r22, r22
 5a4:	62 83       	std	Z+2, r22	; 0x02
 5a6:	da 01       	movw	r26, r20

		/* Fill write data buffer. */
		for (uint8_t bufferIndex=0; bufferIndex < bytesToWrite; bufferIndex++)
 5a8:	80 e0       	ldi	r24, 0x00	; 0
 5aa:	90 e0       	ldi	r25, 0x00	; 0
 5ac:	82 17       	cp	r24, r18
 5ae:	38 f4       	brcc	.+14     	; 0x5be <TWI_MasterWriteRead+0x38>
		{
			twi->writeData[bufferIndex] = writeData[bufferIndex];
 5b0:	3d 91       	ld	r19, X+
 5b2:	ef 01       	movw	r28, r30
 5b4:	c8 0f       	add	r28, r24
 5b6:	d9 1f       	adc	r29, r25
 5b8:	3b 83       	std	Y+3, r19	; 0x03
 5ba:	01 96       	adiw	r24, 0x01	; 1
 5bc:	f7 cf       	rjmp	.-18     	; 0x5ac <TWI_MasterWriteRead+0x26>
		}

		twi->bytesToWrite = bytesToWrite;
 5be:	25 ab       	std	Z+53, r18	; 0x35
		twi->bytesToRead = bytesToRead;
 5c0:	06 ab       	std	Z+54, r16	; 0x36
		twi->bytesWritten = 0;
 5c2:	17 aa       	std	Z+55, r1	; 0x37
		twi->bytesRead = 0;
 5c4:	10 ae       	std	Z+56, r1	; 0x38

		/* If write command, send the START condition + Address +
		* 'R/_W = 0'
		*/
		if (twi->bytesToWrite > 0)
 5c6:	85 a9       	ldd	r24, Z+53	; 0x35
 5c8:	88 23       	and	r24, r24
 5ca:	19 f0       	breq	.+6      	; 0x5d2 <TWI_MasterWriteRead+0x4c>
		{
			uint8_t writeAddress = twi->address & ~0x01;
 5cc:	82 81       	ldd	r24, Z+2	; 0x02
 5ce:	8e 7f       	andi	r24, 0xFE	; 254
 5d0:	05 c0       	rjmp	.+10     	; 0x5dc <TWI_MasterWriteRead+0x56>
		}

		/* If read command, send the START condition + Address +
		* 'R/_W = 1'
		*/
		else if (twi->bytesToRead > 0)
 5d2:	86 a9       	ldd	r24, Z+54	; 0x36
 5d4:	88 23       	and	r24, r24
 5d6:	49 f0       	breq	.+18     	; 0x5ea <TWI_MasterWriteRead+0x64>
		{
			uint8_t readAddress = twi->address | 0x01;
 5d8:	82 81       	ldd	r24, Z+2	; 0x02
 5da:	81 60       	ori	r24, 0x01	; 1
			twi->interface->MASTER.ADDR = readAddress;
 5dc:	01 90       	ld	r0, Z+
 5de:	f0 81       	ld	r31, Z
 5e0:	e0 2d       	mov	r30, r0
 5e2:	86 83       	std	Z+6, r24	; 0x06
 5e4:	02 c0       	rjmp	.+4      	; 0x5ea <TWI_MasterWriteRead+0x64>
bool TWI_MasterWriteRead(TWI_Master_t *twi, uint8_t address, uint8_t *writeData, uint8_t bytesToWrite, uint8_t bytesToRead)
{
	/*Parameter sanity check. */
	if (bytesToWrite > TWIM_WRITE_BUFFER_SIZE)
	{
		return false;
 5e6:	80 e0       	ldi	r24, 0x00	; 0
 5e8:	01 c0       	rjmp	.+2      	; 0x5ec <TWI_MasterWriteRead+0x66>
		{
			uint8_t readAddress = twi->address | 0x01;
			twi->interface->MASTER.ADDR = readAddress;
		}
		
		return true;
 5ea:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return false;
	}
}
 5ec:	df 91       	pop	r29
 5ee:	cf 91       	pop	r28
 5f0:	0f 91       	pop	r16
 5f2:	08 95       	ret

000005f4 <TWI_MasterWrite>:
*
*  \retval true  If transaction could be started.
*  \retval false If transaction could not be started.
*/
bool TWI_MasterWrite(TWI_Master_t *twi, uint8_t address, uint8_t *writeData, uint8_t bytesToWrite)
{
 5f4:	0f 93       	push	r16
	bool twi_status = TWI_MasterWriteRead(twi, address, writeData, bytesToWrite, 0);
 5f6:	00 e0       	ldi	r16, 0x00	; 0
 5f8:	0e 94 c3 02 	call	0x586	; 0x586 <TWI_MasterWriteRead>
	return twi_status;
}
 5fc:	0f 91       	pop	r16
 5fe:	08 95       	ret

00000600 <TWI_MasterRead>:
*
*  \retval true  If transaction could be started.
*  \retval false If transaction could not be started.
*/
bool TWI_MasterRead(TWI_Master_t *twi, uint8_t address, uint8_t bytesToRead)
{
 600:	0f 93       	push	r16
	bool twi_status = TWI_MasterWriteRead(twi, address, 0, 0, bytesToRead);
 602:	04 2f       	mov	r16, r20
 604:	20 e0       	ldi	r18, 0x00	; 0
 606:	40 e0       	ldi	r20, 0x00	; 0
 608:	50 e0       	ldi	r21, 0x00	; 0
 60a:	0e 94 c3 02 	call	0x586	; 0x586 <TWI_MasterWriteRead>
	return twi_status;
}
 60e:	0f 91       	pop	r16
 610:	08 95       	ret

00000612 <TWI_MasterArbitrationLostBusErrorHandler>:
*  Handles TWI responses to lost arbitration and bus error.
*
*  \param twi  The TWI_Master_t struct instance.
*/
void TWI_MasterArbitrationLostBusErrorHandler(TWI_Master_t *twi)
{
 612:	fc 01       	movw	r30, r24
	
	uint8_t currentStatus = twi->interface->MASTER.STATUS;
 614:	a0 81       	ld	r26, Z
 616:	b1 81       	ldd	r27, Z+1	; 0x01
 618:	14 96       	adiw	r26, 0x04	; 4
 61a:	8c 91       	ld	r24, X
 61c:	14 97       	sbiw	r26, 0x04	; 4

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) 
 61e:	82 ff       	sbrs	r24, 2
 620:	02 c0       	rjmp	.+4      	; 0x626 <TWI_MasterArbitrationLostBusErrorHandler+0x14>
	{
		twi->result = TWIM_RESULT_BUS_ERROR;
 622:	94 e0       	ldi	r25, 0x04	; 4
 624:	01 c0       	rjmp	.+2      	; 0x628 <TWI_MasterArbitrationLostBusErrorHandler+0x16>
	}
	/* If arbitration lost. */
	else 
	{
		twi->result = TWIM_RESULT_ARBITRATION_LOST;
 626:	93 e0       	ldi	r25, 0x03	; 3
 628:	92 af       	std	Z+58, r25	; 0x3a
	}

	/* Clear interrupt flag. */
	twi->interface->MASTER.STATUS = currentStatus | TWI_MASTER_ARBLOST_bm;
 62a:	88 60       	ori	r24, 0x08	; 8
 62c:	14 96       	adiw	r26, 0x04	; 4
 62e:	8c 93       	st	X, r24

	twi->status = TWIM_STATUS_READY;
 630:	11 ae       	std	Z+57, r1	; 0x39
 632:	08 95       	ret

00000634 <TWI_MasterWriteHandler>:
*  Handles TWI transactions (master write) and responses to (N)ACK.
*
*  \param twi The TWI_Master_t struct instance.
*/
void TWI_MasterWriteHandler(TWI_Master_t *twi)
{
 634:	cf 93       	push	r28
 636:	df 93       	push	r29
 638:	fc 01       	movw	r30, r24
	/* Local variables used in if tests to avoid compiler warning. */
	uint8_t bytesToWrite  = twi->bytesToWrite;
 63a:	25 a9       	ldd	r18, Z+53	; 0x35
	uint8_t bytesToRead   = twi->bytesToRead;
 63c:	96 a9       	ldd	r25, Z+54	; 0x36

	/* If NOT acknowledged (NACK) by slave cancel the transaction. */
	if (twi->interface->MASTER.STATUS & TWI_MASTER_RXACK_bm) 
 63e:	a0 81       	ld	r26, Z
 640:	b1 81       	ldd	r27, Z+1	; 0x01
 642:	14 96       	adiw	r26, 0x04	; 4
 644:	8c 91       	ld	r24, X
 646:	14 97       	sbiw	r26, 0x04	; 4
 648:	84 ff       	sbrs	r24, 4
 64a:	05 c0       	rjmp	.+10     	; 0x656 <TWI_MasterWriteHandler+0x22>
	{
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
 64c:	83 e0       	ldi	r24, 0x03	; 3
 64e:	13 96       	adiw	r26, 0x03	; 3
 650:	8c 93       	st	X, r24
		twi->result = TWIM_RESULT_NACK_RECEIVED;
 652:	85 e0       	ldi	r24, 0x05	; 5
 654:	1a c0       	rjmp	.+52     	; 0x68a <TWI_MasterWriteHandler+0x56>
		twi->status = TWIM_STATUS_READY;
	}

	/* If more bytes to write, send data. */
	else if (twi->bytesWritten < bytesToWrite) 
 656:	87 a9       	ldd	r24, Z+55	; 0x37
 658:	82 17       	cp	r24, r18
 65a:	58 f4       	brcc	.+22     	; 0x672 <TWI_MasterWriteHandler+0x3e>
	{
		uint8_t data = twi->writeData[twi->bytesWritten];
 65c:	87 a9       	ldd	r24, Z+55	; 0x37
 65e:	ef 01       	movw	r28, r30
 660:	c8 0f       	add	r28, r24
 662:	d1 1d       	adc	r29, r1
 664:	8b 81       	ldd	r24, Y+3	; 0x03
		twi->interface->MASTER.DATA = data;
 666:	17 96       	adiw	r26, 0x07	; 7
 668:	8c 93       	st	X, r24
		++twi->bytesWritten;
 66a:	87 a9       	ldd	r24, Z+55	; 0x37
 66c:	8f 5f       	subi	r24, 0xFF	; 255
 66e:	87 ab       	std	Z+55, r24	; 0x37
 670:	0e c0       	rjmp	.+28     	; 0x68e <TWI_MasterWriteHandler+0x5a>
	}

	/* If bytes to read, send repeated START condition + Address +
	* 'R/_W = 1'
	*/
	else if (twi->bytesRead < bytesToRead) 
 672:	80 ad       	ldd	r24, Z+56	; 0x38
 674:	89 17       	cp	r24, r25
 676:	28 f4       	brcc	.+10     	; 0x682 <TWI_MasterWriteHandler+0x4e>
	{
		uint8_t readAddress = twi->address | 0x01;
 678:	82 81       	ldd	r24, Z+2	; 0x02
 67a:	81 60       	ori	r24, 0x01	; 1
		twi->interface->MASTER.ADDR = readAddress;
 67c:	16 96       	adiw	r26, 0x06	; 6
 67e:	8c 93       	st	X, r24
 680:	06 c0       	rjmp	.+12     	; 0x68e <TWI_MasterWriteHandler+0x5a>
	}

	/* If transaction finished, send STOP condition and set RESULT OK. */
	else 
	{
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
 682:	83 e0       	ldi	r24, 0x03	; 3
 684:	13 96       	adiw	r26, 0x03	; 3
 686:	8c 93       	st	X, r24
*  \param twi     The TWI_Master_t struct instance.
*  \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
 688:	81 e0       	ldi	r24, 0x01	; 1
 68a:	82 af       	std	Z+58, r24	; 0x3a
	twi->status = TWIM_STATUS_READY;
 68c:	11 ae       	std	Z+57, r1	; 0x39
	else 
	{
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
		TWI_MasterTransactionFinished(twi, TWIM_RESULT_OK);
	}
}
 68e:	df 91       	pop	r29
 690:	cf 91       	pop	r28
 692:	08 95       	ret

00000694 <TWI_MasterReadHandler>:
*  reading bytes from the TWI slave.
*
*  \param twi The TWI_Master_t struct instance.
*/
void TWI_MasterReadHandler(TWI_Master_t *twi)
{
 694:	fc 01       	movw	r30, r24
	
	/* Fetch data if bytes to be read. */
	if (twi->bytesRead < TWIM_READ_BUFFER_SIZE) 
 696:	80 ad       	ldd	r24, Z+56	; 0x38
 698:	a0 81       	ld	r26, Z
 69a:	b1 81       	ldd	r27, Z+1	; 0x01
 69c:	89 31       	cpi	r24, 0x19	; 25
 69e:	60 f4       	brcc	.+24     	; 0x6b8 <TWI_MasterReadHandler+0x24>
	{
		uint8_t data = twi->interface->MASTER.DATA;
 6a0:	17 96       	adiw	r26, 0x07	; 7
 6a2:	8c 91       	ld	r24, X
		twi->readData[twi->bytesRead] = data;
 6a4:	90 ad       	ldd	r25, Z+56	; 0x38
 6a6:	df 01       	movw	r26, r30
 6a8:	a9 0f       	add	r26, r25
 6aa:	b1 1d       	adc	r27, r1
 6ac:	5c 96       	adiw	r26, 0x1c	; 28
 6ae:	8c 93       	st	X, r24
		twi->bytesRead++;
 6b0:	80 ad       	ldd	r24, Z+56	; 0x38
 6b2:	8f 5f       	subi	r24, 0xFF	; 255
 6b4:	80 af       	std	Z+56, r24	; 0x38
 6b6:	06 c0       	rjmp	.+12     	; 0x6c4 <TWI_MasterReadHandler+0x30>
	}

	/* If buffer overflow, issue STOP and BUFFER_OVERFLOW condition. */
	else 
	{
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
 6b8:	83 e0       	ldi	r24, 0x03	; 3
 6ba:	13 96       	adiw	r26, 0x03	; 3
 6bc:	8c 93       	st	X, r24
*  \param twi     The TWI_Master_t struct instance.
*  \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
 6be:	82 e0       	ldi	r24, 0x02	; 2
 6c0:	82 af       	std	Z+58, r24	; 0x3a
	twi->status = TWIM_STATUS_READY;
 6c2:	11 ae       	std	Z+57, r1	; 0x39
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
		TWI_MasterTransactionFinished(twi, TWIM_RESULT_BUFFER_OVERFLOW);
	}

	/* Local variable used in if test to avoid compiler warning. */
	uint8_t bytesToRead = twi->bytesToRead;
 6c4:	96 a9       	ldd	r25, Z+54	; 0x36

	/* If more bytes to read, issue ACK and start a byte read. */
	if (twi->bytesRead < bytesToRead) 
 6c6:	80 ad       	ldd	r24, Z+56	; 0x38
 6c8:	a0 81       	ld	r26, Z
 6ca:	b1 81       	ldd	r27, Z+1	; 0x01
 6cc:	89 17       	cp	r24, r25
 6ce:	20 f4       	brcc	.+8      	; 0x6d8 <TWI_MasterReadHandler+0x44>
	{
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
 6d0:	82 e0       	ldi	r24, 0x02	; 2
 6d2:	13 96       	adiw	r26, 0x03	; 3
 6d4:	8c 93       	st	X, r24
 6d6:	08 95       	ret
	}

	/* If transaction finished, issue NACK and STOP condition. */
	else 
	{
		twi->interface->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
 6d8:	87 e0       	ldi	r24, 0x07	; 7
 6da:	13 96       	adiw	r26, 0x03	; 3
 6dc:	8c 93       	st	X, r24
*  \param twi     The TWI_Master_t struct instance.
*  \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
 6de:	81 e0       	ldi	r24, 0x01	; 1
 6e0:	82 af       	std	Z+58, r24	; 0x3a
	twi->status = TWIM_STATUS_READY;
 6e2:	11 ae       	std	Z+57, r1	; 0x39
 6e4:	08 95       	ret

000006e6 <TWI_MasterInterruptHandler>:
*
*  \param twi  The TWI_Master_t struct instance.
*/
void TWI_MasterInterruptHandler(TWI_Master_t *twi)
{
	uint8_t currentStatus = twi->interface->MASTER.STATUS;
 6e6:	dc 01       	movw	r26, r24
 6e8:	ed 91       	ld	r30, X+
 6ea:	fc 91       	ld	r31, X
 6ec:	24 81       	ldd	r18, Z+4	; 0x04
	
	/* If arbitration lost or bus error. */
	if ((currentStatus & TWI_MASTER_ARBLOST_bm) || (currentStatus & TWI_MASTER_BUSERR_bm))
 6ee:	32 2f       	mov	r19, r18
 6f0:	3c 70       	andi	r19, 0x0C	; 12
 6f2:	11 f0       	breq	.+4      	; 0x6f8 <TWI_MasterInterruptHandler+0x12>
	{
		TWI_MasterArbitrationLostBusErrorHandler(twi);
 6f4:	0c 94 09 03 	jmp	0x612	; 0x612 <TWI_MasterArbitrationLostBusErrorHandler>
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) 
 6f8:	26 fd       	sbrc	r18, 6
	{
		TWI_MasterWriteHandler(twi);
 6fa:	0c 94 1a 03 	jmp	0x634	; 0x634 <TWI_MasterWriteHandler>
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) 
 6fe:	27 fd       	sbrc	r18, 7
	{
		TWI_MasterReadHandler(twi);
 700:	0c 94 4a 03 	jmp	0x694	; 0x694 <TWI_MasterReadHandler>
*  \param twi     The TWI_Master_t struct instance.
*  \param result  The result of the operation.
*/
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
 704:	26 e0       	ldi	r18, 0x06	; 6
 706:	fc 01       	movw	r30, r24
 708:	22 af       	std	Z+58, r18	; 0x3a
	twi->status = TWIM_STATUS_READY;
 70a:	11 ae       	std	Z+57, r1	; 0x39
 70c:	08 95       	ret

0000070e <_exit>:
 70e:	f8 94       	cli

00000710 <__stop_program>:
 710:	ff cf       	rjmp	.-2      	; 0x710 <__stop_program>
